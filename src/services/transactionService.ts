import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  getDocs,
  query,
  where,
  Timestamp
} from 'firebase/firestore';
import { db } from '../config/firebase';

export interface Transaction {
  id: string;
  type: 'receita' | 'despesa';
  category: string;
  description: string;
  amount: number;
  date: Date;
  paymentMethod: 'dinheiro' | 'pix' | 'cartao' | 'transferencia';
  status: 'pago' | 'pendente';
  financialType: string;
  userId: string;
  createdAt: Date;
  updatedAt: Date;
  // Campos opcionais
  saleId?: string;
  autoGenerated?: boolean;
  saleGenerated?: boolean;
  stockGenerated?: boolean;
  stockMovementGenerated?: boolean;
  costOfGoodsSold?: boolean;
  productName?: string;
  supplier?: string;
  notes?: string;
}

interface TransactionFormData {
  type: 'receita' | 'despesa';
  category: string;
  description: string;
  amount: number;
  date: string;
  paymentMethod: 'dinheiro' | 'pix' | 'cartao' | 'transferencia';
  status: 'pago' | 'pendente';
  financialType: string;
  notes?: string;
}

const COLLECTION_NAME = 'transactions';

export const transactionService = {
  // Criar transação
  async createTransaction(transactionData: TransactionFormData, userId: string): Promise<string> {
    try {
      const docRef = await addDoc(collection(db, COLLECTION_NAME), {
        ...transactionData,
        amount: Number(transactionData.amount),
        date: new Date(transactionData.date),
        userId,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now()
      });

      console.log('✅ Transação criada no Firebase:', docRef.id);
      return docRef.id;
    } catch (error) {
      console.error('❌ Erro ao criar transação:', error);
      throw error;
    }
  },

  // Listar transações do usuário
  async getTransactions(userId: string): Promise<Transaction[]> {
    try {
      const q = query(
        collection(db, COLLECTION_NAME),
        where('userId', '==', userId)
      );

      const querySnapshot = await getDocs(q);
      const transactions: Transaction[] = [];

      querySnapshot.forEach((doc) => {
        const data = doc.data();
        transactions.push({
          id: doc.id,
          ...data,
          date: data.date?.toDate() || new Date(),
          createdAt: data.createdAt?.toDate() || new Date(),
          updatedAt: data.updatedAt?.toDate() || new Date()
        } as Transaction);
      });

      console.log(`✅ ${transactions.length} transações carregadas do Firebase`);

      // Ordenação em memória para evitar erros de índice
      return transactions.sort((a, b) => b.date.getTime() - a.date.getTime());
    } catch (error) {
      console.error('❌ Erro ao buscar transações:', error);
      throw error;
    }
  },

  // Atualizar transação
  async updateTransaction(transactionId: string, transactionData: Partial<TransactionFormData>): Promise<void> {
    try {
      const transactionRef = doc(db, COLLECTION_NAME, transactionId);

      const updateData: any = {
        ...transactionData,
        updatedAt: Timestamp.now()
      };

      if (transactionData.amount) {
        updateData.amount = Number(transactionData.amount);
      }

      if (transactionData.date) {
        updateData.date = new Date(transactionData.date);
      }

      await updateDoc(transactionRef, updateData);
      console.log('✅ Transação atualizada no Firebase:', transactionId);
    } catch (error) {
      console.error('❌ Erro ao atualizar transação:', error);
      throw error;
    }
  },

  // Deletar transação
  async deleteTransaction(transactionId: string): Promise<void> {
    try {
      await deleteDoc(doc(db, COLLECTION_NAME, transactionId));
      console.log('✅ Transação deletada do Firebase:', transactionId);
    } catch (error) {
      console.error('❌ Erro ao deletar transação:', error);
      throw error;
    }
  },

  // Buscar transações por período
  async getTransactionsByPeriod(userId: string, startDate: Date, endDate: Date): Promise<Transaction[]> {
    try {
      const q = query(
        collection(db, COLLECTION_NAME),
        where('userId', '==', userId),
        where('date', '>=', startDate),
        where('date', '<=', endDate)
      );

      const querySnapshot = await getDocs(q);
      const transactions: Transaction[] = [];

      querySnapshot.forEach((doc) => {
        const data = doc.data();
        transactions.push({
          id: doc.id,
          ...data,
          date: data.date?.toDate() || new Date(),
          createdAt: data.createdAt?.toDate() || new Date(),
          updatedAt: data.updatedAt?.toDate() || new Date()
        } as Transaction);
      });

      return transactions.sort((a, b) => b.date.getTime() - a.date.getTime());
    } catch (error) {
      console.error('❌ Erro ao buscar transações por período:', error);
      throw error;
    }
  },

  // Buscar transações por tipo
  async getTransactionsByType(userId: string, type: 'receita' | 'despesa'): Promise<Transaction[]> {
    try {
      const q = query(
        collection(db, COLLECTION_NAME),
        where('userId', '==', userId),
        where('type', '==', type)
      );

      const querySnapshot = await getDocs(q);
      const transactions: Transaction[] = [];

      querySnapshot.forEach((doc) => {
        const data = doc.data();
        transactions.push({
          id: doc.id,
          ...data,
          date: data.date?.toDate() || new Date(),
          createdAt: data.createdAt?.toDate() || new Date(),
          updatedAt: data.updatedAt?.toDate() || new Date()
        } as Transaction);
      });

      return transactions.sort((a, b) => b.date.getTime() - a.date.getTime());
    } catch (error) {
      console.error('❌ Erro ao buscar transações por tipo:', error);
      throw error;
    }
  },

  // Migrar dados do localStorage para Firebase
  async migrateFromLocalStorage(userId: string): Promise<number> {
    try {
      const localData = localStorage.getItem(`transactions_${userId}`);
      if (!localData) {
        console.log('ℹ️ Nenhum dado para migrar do localStorage');
        return 0;
      }

      const transactions = JSON.parse(localData);
      let migratedCount = 0;

      for (const transaction of transactions) {
        try {
          // Verificar se já existe no Firebase (evitar duplicatas)
          const existingQuery = query(
            collection(db, COLLECTION_NAME),
            where('userId', '==', userId),
            where('description', '==', transaction.description),
            where('amount', '==', transaction.amount),
            where('date', '==', new Date(transaction.date))
          );

          const existingDocs = await getDocs(existingQuery);

          if (existingDocs.empty) {
            await addDoc(collection(db, COLLECTION_NAME), {
              ...transaction,
              date: new Date(transaction.date),
              createdAt: transaction.createdAt ? new Date(transaction.createdAt) : Timestamp.now(),
              updatedAt: Timestamp.now(),
              userId
            });
            migratedCount++;
          }
        } catch (error) {
          console.error('Erro ao migrar transação individual:', error);
        }
      }

      console.log(`✅ ${migratedCount} transações migradas do localStorage para Firebase`);
      return migratedCount;
    } catch (error) {
      console.error('❌ Erro ao migrar transações:', error);
      throw error;
    }
  }
};
