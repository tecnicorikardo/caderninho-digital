require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const admin = require('firebase-admin');
const Groq = require('groq-sdk');
const express = require('express');

// --- Configura√ß√µes ---
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const GROQ_API_KEY = process.env.GROQ_API_KEY;
const FIREBASE_PROJECT_ID = 'web-gestao-37a85'; // SEU PROJECT ID CORRETO
const PORT = process.env.PORT || 3000;

// Inicializa o Telegram Bot
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });
console.log('ü§ñ Telegram bot inicializado...');

// Inicializa o Firebase Admin SDK
let db;
try {
  // Para produ√ß√£o, use vari√°vel de ambiente
  if (process.env.FIREBASE_SERVICE_ACCOUNT) {
    const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
      projectId: FIREBASE_PROJECT_ID
    });
  } else {
    // Para desenvolvimento local
    const serviceAccount = require('./serviceAccountKey.json');
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
      projectId: FIREBASE_PROJECT_ID
    });
  }
  
  db = admin.firestore();
  console.log('üî• Firebase Admin SDK inicializado...');
} catch (error) {
  console.error('‚ùå Erro ao inicializar Firebase Admin SDK:', error.message);
  console.log('‚ö†Ô∏è  Continuando com dados simulados...');
  db = null;
}

// Inicializa Groq SDK
const groq = new Groq({
  apiKey: GROQ_API_KEY
});
console.log('üß† Groq SDK inicializado...');

// --- Mapeamento de usu√°rios Telegram para Firebase ---
const userMapping = new Map();

// Fun√ß√£o para buscar todos os userIds do Firebase
async function getAllFirebaseUserIds() {
  if (!db) return [];
  
  try {
    const userIds = new Set();
    
    // Buscar em todas as cole√ß√µes para encontrar userIds √∫nicos
    const collections = ['sales', 'clients', 'products'];
    
    console.log('üîç Buscando userIds em todas as cole√ß√µes...');
    
    for (const collectionName of collections) {
      console.log(`üìã Verificando cole√ß√£o: ${collectionName}`);
      const snapshot = await db.collection(collectionName).get();
      console.log(`üìä ${collectionName}: ${snapshot.size} documentos encontrados`);
      
      snapshot.forEach(doc => {
        const data = doc.data();
        console.log(`üìÑ Documento ${doc.id}:`, {
          userId: data.userId,
          hasUserId: !!data.userId
        });
        
        if (data.userId) {
          userIds.add(data.userId);
          console.log(`‚úÖ UserId encontrado: ${data.userId}`);
        }
      });
    }
    
    console.log(`üéØ Total de userIds √∫nicos encontrados: ${userIds.size}`);
    console.log('üìã UserIds:', Array.from(userIds));
    
    return Array.from(userIds);
  } catch (error) {
    console.error('‚ùå Erro ao buscar userIds:', error);
    return [];
  }
}

// Fun√ß√£o para registrar/obter userId
function getUserId(telegramUserId, firstName) {
  if (!userMapping.has(telegramUserId)) {
    // Usar ID baseado no Telegram por padr√£o
    const userId = `telegram_${telegramUserId}`;
    userMapping.set(telegramUserId, {
      firebaseUserId: userId,
      firstName: firstName,
      registeredAt: new Date(),
      isAuthenticated: false
    });
    console.log(`üë§ Novo usu√°rio registrado: ${firstName} (${userId})`);
  }
  return userMapping.get(telegramUserId).firebaseUserId;
}

// Fun√ß√£o para autenticar usu√°rio com dados reais
async function authenticateUser(telegramUserId, targetUserId) {
  if (!db) return false;
  
  try {
    // Verificar se o userId existe no Firebase
    const salesRef = db.collection('sales').where('userId', '==', targetUserId).limit(1);
    const snapshot = await salesRef.get();
    
    if (!snapshot.empty) {
      // Atualizar mapeamento para usar o userId real
      const userData = userMapping.get(telegramUserId) || {};
      userMapping.set(telegramUserId, {
        ...userData,
        firebaseUserId: targetUserId,
        isAuthenticated: true,
        authenticatedAt: new Date()
      });
      
      console.log(`‚úÖ Usu√°rio autenticado: ${targetUserId}`);
      return true;
    }
    
    return false;
  } catch (error) {
    console.error('‚ùå Erro na autentica√ß√£o:', error);
    return false;
  }
}

// --- Fun√ß√µes Firebase REAIS ---

async function getSalesSummary(userId) {
  if (!db) {
    // Dados simulados quando Firebase n√£o est√° conectado
    return {
      totalToday: 0.00,
      countToday: 0,
      averageTicket: 0.00,
      sales: [],
      pendingPayments: [],
      isSimulated: true
    };
  }

  try {
    console.log(`üìä Buscando vendas para usu√°rio: ${userId}`);
    
    // Primeiro, vamos ver TODAS as vendas para debug
    console.log('üîç DEBUG: Verificando TODAS as vendas primeiro...');
    const allSalesSnapshot = await db.collection('sales').get();
    console.log(`üìã Total de vendas no sistema: ${allSalesSnapshot.size}`);
    
    allSalesSnapshot.forEach((doc, index) => {
      const data = doc.data();
      console.log(`üìÑ Venda ${index + 1}:`, {
        id: doc.id,
        userId: data.userId,
        total: data.total,
        clientName: data.clientName
      });
    });
    
    // Agora buscar vendas do usu√°rio espec√≠fico
    const salesRef = db.collection('sales').where('userId', '==', userId);
    const snapshot = await salesRef.get();
    
    console.log(`üéØ Vendas encontradas para userId '${userId}': ${snapshot.size}`);
    
    if (snapshot.empty) {
      console.log('üì≠ Nenhuma venda encontrada para este usu√°rio');
      return {
        totalToday: 0.00,
        countToday: 0,
        averageTicket: 0.00,
        sales: [],
        pendingPayments: [],
        isSimulated: false
      };
    }

    const sales = [];
    const today = new Date();
    const todayString = today.toISOString().split('T')[0];
    
    let totalToday = 0;
    let countToday = 0;
    const pendingPayments = [];

    snapshot.forEach((doc) => {
      const data = doc.data();
      const sale = {
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate() || new Date(),
        updatedAt: data.updatedAt?.toDate() || new Date()
      };
      
      sales.push(sale);
      
      // Verificar se √© venda de hoje
      const saleDate = sale.createdAt.toISOString().split('T')[0];
      if (saleDate === todayString) {
        totalToday += sale.total || 0;
        countToday++;
      }
      
      // Verificar pagamentos pendentes
      if (sale.paymentStatus === 'pendente' || sale.paymentStatus === 'parcial') {
        pendingPayments.push({
          id: sale.id,
          total: sale.total,
          clientName: sale.clientName || 'Cliente n√£o informado',
          remainingAmount: sale.remainingAmount || sale.total,
          dueDate: sale.createdAt.toISOString().split('T')[0]
        });
      }
    });

    const averageTicket = countToday > 0 ? totalToday / countToday : 0;

    console.log(`‚úÖ Encontradas ${sales.length} vendas, ${countToday} hoje`);
    
    return {
      totalToday,
      countToday,
      averageTicket,
      sales: sales.slice(0, 5), // √öltimas 5 vendas
      pendingPayments,
      isSimulated: false
    };
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar vendas:', error);
    throw error;
  }
}

async function getClientsSummary(userId) {
  if (!db) {
    return {
      total: 0,
      newThisMonth: 0,
      withPendingPayments: 0,
      topClients: [],
      isSimulated: true
    };
  }

  try {
    console.log(`üë• Buscando clientes para usu√°rio: ${userId}`);
    
    const clientsRef = db.collection('clients').where('userId', '==', userId);
    const snapshot = await clientsRef.get();
    
    if (snapshot.empty) {
      return {
        total: 0,
        newThisMonth: 0,
        withPendingPayments: 0,
        topClients: [],
        isSimulated: false
      };
    }

    const clients = [];
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    let newThisMonth = 0;

    snapshot.forEach((doc) => {
      const data = doc.data();
      const client = {
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate() || new Date()
      };
      
      clients.push(client);
      
      // Verificar se √© cliente novo este m√™s
      const clientMonth = client.createdAt.getMonth();
      const clientYear = client.createdAt.getFullYear();
      if (clientMonth === currentMonth && clientYear === currentYear) {
        newThisMonth++;
      }
    });

    // Buscar vendas para calcular top clientes
    const salesRef = db.collection('sales').where('userId', '==', userId);
    const salesSnapshot = await salesRef.get();
    
    const clientPurchases = new Map();
    
    salesSnapshot.forEach((doc) => {
      const sale = doc.data();
      if (sale.clientId) {
        const current = clientPurchases.get(sale.clientId) || 0;
        clientPurchases.set(sale.clientId, current + (sale.total || 0));
      }
    });

    const topClients = clients
      .map(client => ({
        id: client.id,
        name: client.name,
        totalPurchases: clientPurchases.get(client.id) || 0
      }))
      .filter(client => client.totalPurchases > 0)
      .sort((a, b) => b.totalPurchases - a.totalPurchases)
      .slice(0, 5);

    console.log(`‚úÖ Encontrados ${clients.length} clientes`);
    
    return {
      total: clients.length,
      newThisMonth,
      withPendingPayments: 0, // Seria calculado com base nas vendas pendentes
      topClients,
      isSimulated: false
    };
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar clientes:', error);
    throw error;
  }
}

async function getProductsSummary(userId) {
  if (!db) {
    return {
      total: 0,
      lowStock: 0,
      totalValue: 0.00,
      productsLowStock: [],
      isSimulated: true
    };
  }

  try {
    console.log(`üì¶ Buscando produtos para usu√°rio: ${userId}`);
    
    const productsRef = db.collection('products').where('userId', '==', userId);
    const snapshot = await productsRef.get();
    
    if (snapshot.empty) {
      return {
        total: 0,
        lowStock: 0,
        totalValue: 0.00,
        productsLowStock: [],
        isSimulated: false
      };
    }

    const products = [];
    let totalValue = 0;
    const productsLowStock = [];

    snapshot.forEach((doc) => {
      const data = doc.data();
      const product = {
        id: doc.id,
        ...data
      };
      
      products.push(product);
      
      // Calcular valor total do estoque
      totalValue += (product.quantity || 0) * (product.salePrice || 0);
      
      // Verificar estoque baixo
      const minQty = product.minQuantity || 5;
      if ((product.quantity || 0) <= minQty) {
        productsLowStock.push({
          id: product.id,
          name: product.name,
          quantity: product.quantity || 0,
          minQuantity: minQty
        });
      }
    });

    console.log(`‚úÖ Encontrados ${products.length} produtos`);
    
    return {
      total: products.length,
      lowStock: productsLowStock.length,
      totalValue,
      productsLowStock: productsLowStock.slice(0, 10), // Primeiros 10
      isSimulated: false
    };
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar produtos:', error);
    throw error;
  }
}

// --- Comandos do Bot Telegram ---

// Comando /start - com login autom√°tico
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  let userData = userMapping.get(msg.from.id);
  
  // Tentar login autom√°tico se n√£o estiver autenticado
  if (!userData?.isAuthenticated) {
    console.log(`üîê Tentando login autom√°tico para ${msg.from.first_name}...`);
    const realUserId = 'ECYMxTpm46b2iNUNU0aNHIbdfTJ2'; // Seu userId real
    const success = await authenticateUser(msg.from.id, realUserId);
    
    if (success) {
      userData = userMapping.get(msg.from.id); // Atualizar dados ap√≥s login
      
      const welcomeMessage = `üéâ *Ol√°, ${msg.from.first_name}!*

‚úÖ *Login autom√°tico realizado!*
üÜî *Conectado √† sua conta empresarial*

ü§ñ *Caderninho Digital Chatbot IA*
Seu assistente inteligente para gest√£o do neg√≥cio.

üí¨ *Experimente agora:*
‚Ä¢ "Quanto vendi hoje?"
‚Ä¢ "Como est√° meu estoque?"
‚Ä¢ "Quem s√£o meus clientes?"
‚Ä¢ "Resumo do m√™s"

üåê *Sistema:* https://web-gestao-37a85.web.app`;

      const buttons = [
        [
          { text: 'üìä Ver Vendas', callback_data: 'vendas_detalhadas' },
          { text: 'üë• Ver Clientes', callback_data: 'clientes_detalhados' }
        ],
        [
          { text: 'üì¶ Ver Estoque', callback_data: 'estoque_detalhado' },
          { text: 'üìà Dashboard', callback_data: 'dashboard' }
        ]
      ];
      
      await sendMessageWithButtons(chatId, welcomeMessage, buttons);
      return;
    }
  }
  
  // Se j√° est√° autenticado
  if (userData?.isAuthenticated) {
    const welcomeMessage = `üëã *Oi novamente, ${msg.from.first_name}!*

‚úÖ *Voc√™ est√° conectado √† sua conta*
üÜî *ID:* \`${userData.firebaseUserId}\`

üí¨ *O que gostaria de saber sobre seu neg√≥cio?*`;

    const buttons = [
      [
        { text: 'üìä Vendas', callback_data: 'vendas_detalhadas' },
        { text: 'üë• Clientes', callback_data: 'clientes_detalhados' }
      ],
      [
        { text: 'üì¶ Estoque', callback_data: 'estoque_detalhado' },
        { text: 'üîÑ Trocar Conta', callback_data: 'logout_confirm' }
      ]
    ];
    
    await sendMessageWithButtons(chatId, welcomeMessage, buttons);
    return;
  }
  
  // Se n√£o conseguiu autenticar automaticamente
  const welcomeMessage = `üéâ *Ol√°, ${msg.from.first_name}!*

ü§ñ *Caderninho Digital Chatbot IA*
Assistente para empres√°rios.

üîê *Para acessar seus dados empresariais:*

Use o bot√£o abaixo para login autom√°tico ou digite:
\`/forcelogin\`

üåê *N√£o tem conta? Cadastre-se:*
https://web-gestao-37a85.web.app`;

  const buttons = [
    [{ text: 'üîê Login Autom√°tico', callback_data: 'auto_login' }],
    [{ text: '‚ùì Ajuda', callback_data: 'ajuda_completa' }]
  ];
  
  await sendMessageWithButtons(chatId, welcomeMessage, buttons);
});

// Comando /ajuda
bot.onText(/\/ajuda/, (msg) => {
  const chatId = msg.chat.id;
  const helpMessage = `‚ùì *Central de Ajuda - Caderninho Digital Bot*

üè¢ *Para empres√°rios que usam o Caderninho Digital*

üîê *Como conectar sua conta:*
\`/login seu@email.com suasenha\`

üìä *Comandos dispon√≠veis:*
/start - Menu inicial
/ajuda - Esta ajuda
/status - Status da sua conex√£o
/logout - Desconectar da conta
/usuarios - Ver contas dispon√≠veis (admin)

üí¨ *Consultas que posso fazer:*
‚Ä¢ "Quanto vendi hoje?"
‚Ä¢ "Quantos clientes tenho?"
‚Ä¢ "Produtos com estoque baixo?"
‚Ä¢ "Quem est√° devendo?"
‚Ä¢ "Resumo financeiro do m√™s"
‚Ä¢ "Melhores clientes"
‚Ä¢ "An√°lise de performance"

ü§ñ *Intelig√™ncia Artificial:*
Converse naturalmente comigo! Entendo perguntas sobre seu neg√≥cio.

üåê *Sistema com dados:*
https://web-gestao-37a85.web.app

üìû *Suporte:* Entre em contato pelo sistema web`;

  bot.sendMessage(chatId, helpMessage, { parse_mode: 'Markdown' });
});

// Comando /status
bot.onText(/\/status/, async (msg) => {
  const chatId = msg.chat.id;
  const firebaseStatus = db ? 'üü¢ Conectado' : 'üî¥ Desconectado (dados simulados)';
  const groqStatus = GROQ_API_KEY ? 'üü¢ Conectado' : 'üî¥ N√£o configurado';
  const currentUserId = getUserId(msg.from.id, msg.from.first_name);
  const userData = userMapping.get(msg.from.id);
  const authStatus = userData?.isAuthenticated ? 'üü¢ Autenticado' : 'üü° N√£o autenticado';
  
  const statusMessage = `üìä *Status do Sistema*

üî• *Firebase:* ${firebaseStatus}
üß† *Groq AI:* ${groqStatus}
ü§ñ *Bot:* üü¢ Online
üîê *Autentica√ß√£o:* ${authStatus}

üë§ *Seu ID atual:* \`${currentUserId}\`

${!userData?.isAuthenticated ? '\n‚ö†Ô∏è *Para ver seus dados reais, use /login*' : ''}
${!db ? '\n‚ö†Ô∏è *Aviso:* Firebase desconectado. Usando dados simulados.' : ''}`;

  bot.sendMessage(chatId, statusMessage, { parse_mode: 'Markdown' });
});

// Comando /forcelogin - login direto com dados reais encontrados
bot.onText(/\/forcelogin/, async (msg) => {
  const chatId = msg.chat.id;
  const realUserId = 'ECYMxTpm46b2iNUNU0aNHIbdfTJ2'; // Seu userId real
  
  try {
    bot.sendMessage(chatId, 'üîê Conectando com seus dados reais...');
    
    const success = await authenticateUser(msg.from.id, realUserId);
    
    if (success) {
      bot.sendMessage(chatId, `‚úÖ *CONECTADO COM SUCESSO!*\n\nüÜî *Seus dados:* \`${realUserId}\`\n\nüéâ *Agora teste:*\n‚Ä¢ "Quanto vendi hoje?"\n‚Ä¢ "Quantos clientes tenho?"\n‚Ä¢ "Como est√° meu estoque?"`, { parse_mode: 'Markdown' });
    } else {
      bot.sendMessage(chatId, '‚ùå Erro na conex√£o');
    }
  } catch (error) {
    console.error('‚ùå Erro no forcelogin:', error);
    bot.sendMessage(chatId, '‚ùå Erro na conex√£o');
  }
});

// Comando /debug - verificar dados no Firebase
bot.onText(/\/debug/, async (msg) => {
  const chatId = msg.chat.id;
  
  if (!db) {
    bot.sendMessage(chatId, '‚ùå Firebase n√£o conectado');
    return;
  }
  
  try {
    bot.sendMessage(chatId, 'üîç Analisando dados no Firebase...');
    
    let debugInfo = 'üîç *Debug do Firebase*\n\n';
    
    // Verificar cada cole√ß√£o
    const collections = ['sales', 'clients', 'products'];
    
    for (const collectionName of collections) {
      const snapshot = await db.collection(collectionName).get();
      debugInfo += `üìã *${collectionName}:* ${snapshot.size} documentos\n`;
      
      if (snapshot.size > 0) {
        debugInfo += `‚îî Exemplo de userId: \`${snapshot.docs[0].data().userId || 'N/A'}\`\n`;
      }
    }
    
    // Buscar todos os userIds
    const userIds = await getAllFirebaseUserIds();
    debugInfo += `\nüë• *UserIds √∫nicos:* ${userIds.length}\n`;
    
    if (userIds.length > 0) {
      debugInfo += `‚îî Primeiro: \`${userIds[0]}\`\n`;
      debugInfo += `\nüí° *Teste:* \`/login ${userIds[0]}\``;
    }
    
    bot.sendMessage(chatId, debugInfo, { parse_mode: 'Markdown' });
    
  } catch (error) {
    console.error('‚ùå Erro no debug:', error);
    bot.sendMessage(chatId, `‚ùå Erro: ${error.message}`);
  }
});

// Comando /usuarios - listar usu√°rios (administrativo)
bot.onText(/\/usuarios/, async (msg) => {
  const chatId = msg.chat.id;
  
  if (!db) {
    bot.sendMessage(chatId, '‚ùå Sistema temporariamente indispon√≠vel.');
    return;
  }
  
  try {
    bot.sendMessage(chatId, 'üîç Verificando contas no sistema...');
    
    const userIds = await getAllFirebaseUserIds();
    
    if (userIds.length === 0) {
      bot.sendMessage(chatId, `üì≠ *Nenhuma conta empresarial encontrada*\n\nüåê *Seja o primeiro a se cadastrar:*\nhttps://caderninhodigital.netlify.app\n\nüíº *Benef√≠cios:*\n‚Ä¢ Gest√£o completa do seu neg√≥cio\n‚Ä¢ Relat√≥rios autom√°ticos\n‚Ä¢ Controle de estoque\n‚Ä¢ An√°lise de vendas`);
      return;
    }
    
    let message = `üìä *Status do Sistema*\n\nüë• *Contas empresariais ativas:* ${userIds.length}\n\nüîê *Para acessar sua conta:*\n\`/login seu@email.com suasenha\`\n\n`;
    
    if (userIds.length < 5) {
      message += `üÜî *IDs dispon√≠veis (para teste):*\n`;
      for (let i = 0; i < userIds.length && i < 3; i++) {
        const userId = userIds[i];
        message += `‚Ä¢ \`${userId}\`\n`;
      }
      message += `\nüí° *Teste r√°pido:* \`/login ${userIds[0]}\``;
    }
    
    message += `\n\nüåê *Sistema:*\nhttps://web-gestao-37a85.web.app`;
    
    bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
    
  } catch (error) {
    console.error('‚ùå Erro ao listar usu√°rios:', error);
    bot.sendMessage(chatId, '‚ùå Erro ao verificar sistema. Tente novamente.');
  }
});

// Comando /login - aceita tanto "email senha" quanto "userId" direto
bot.onText(/\/login (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const input = match[1].trim();
  
  // Se tem espa√ßo, √© email e senha
  if (input.includes(' ')) {
    const parts = input.split(' ');
    const email = parts[0];
    const password = parts[1];
    
    await handleEmailPasswordLogin(chatId, msg.from.id, email, password);
  } else {
    // Se n√£o tem espa√ßo, √© userId direto
    await handleUserIdLogin(chatId, msg.from.id, input);
  }
});

// Fun√ß√£o para login com email e senha
async function handleEmailPasswordLogin(chatId, telegramUserId, email, password) {
  if (!db) {
    bot.sendMessage(chatId, '‚ùå Sistema temporariamente indispon√≠vel. Tente novamente em alguns minutos.');
    return;
  }
  
  try {
    bot.sendMessage(chatId, `üîê Autenticando ${email}...`);
    
    // Por enquanto, vamos simular autentica√ß√£o e buscar userId por email
    // Em produ√ß√£o, voc√™ integraria com Firebase Auth
    const userIds = await getAllFirebaseUserIds();
    
    if (userIds.length === 0) {
      bot.sendMessage(chatId, `‚ùå *Nenhuma conta encontrada*\n\nO sistema ainda n√£o possui contas cadastradas.\n\nüåê *Cadastre-se em:*\nhttps://caderninhodigital.netlify.app`);
      return;
    }
    
    // Simular login bem-sucedido com o primeiro userId encontrado
    // Em produ√ß√£o, voc√™ validaria email/senha no Firebase Auth
    const targetUserId = userIds[0]; // Por enquanto, usar o primeiro usu√°rio
    
    const success = await authenticateUser(telegramUserId, targetUserId);
    
    if (success) {
      // Salvar informa√ß√µes do usu√°rio
      const userData = userMapping.get(telegramUserId);
      userMapping.set(telegramUserId, {
        ...userData,
        email: email,
        loginMethod: 'email_password'
      });
      
      bot.sendMessage(chatId, `‚úÖ *Login realizado com sucesso!*\n\nüë§ *Conta:* ${email}\nüÜî *ID:* \`${targetUserId}\`\nüïê *Conectado em:* ${new Date().toLocaleString('pt-BR')}\n\nüéâ *Agora voc√™ pode consultar seus dados empresariais!*\n\nüí¨ *Experimente:*\n‚Ä¢ "Quanto vendi hoje?"\n‚Ä¢ "Como est√° meu estoque?"\n‚Ä¢ "Quem s√£o meus clientes?"`, { parse_mode: 'Markdown' });
    } else {
      bot.sendMessage(chatId, `‚ùå *Falha na autentica√ß√£o*\n\nüìß Email ou senha incorretos.\n\nüí° *Dicas:*\n‚Ä¢ Verifique se digitou corretamente\n‚Ä¢ Use o mesmo email do cadastro\n‚Ä¢ Caso esqueceu a senha, acesse o sistema web\n\nüåê *Recuperar senha:*\nhttps://caderninhodigital.netlify.app`);
    }
    
  } catch (error) {
    console.error('‚ùå Erro no login:', error);
    bot.sendMessage(chatId, '‚ùå Erro durante autentica√ß√£o. Tente novamente em alguns minutos.');
  }
}

// Fun√ß√£o para login direto com userId
async function handleUserIdLogin(chatId, telegramUserId, targetUserId) {
  if (!db) {
    bot.sendMessage(chatId, '‚ùå Sistema temporariamente indispon√≠vel.');
    return;
  }
  
  try {
    bot.sendMessage(chatId, `üîê Conectando com userId: \`${targetUserId}\`...`, { parse_mode: 'Markdown' });
    
    const success = await authenticateUser(telegramUserId, targetUserId);
    
    if (success) {
      bot.sendMessage(chatId, `‚úÖ *Conectado com sucesso!*\n\nüÜî *UserID:* \`${targetUserId}\`\nüïê *Conectado em:* ${new Date().toLocaleString('pt-BR')}\n\nüéâ *Agora voc√™ pode consultar os dados!*\n\nüí¨ *Teste:*\n‚Ä¢ "Quanto vendi hoje?"\n‚Ä¢ "Como est√° meu estoque?"`, { parse_mode: 'Markdown' });
    } else {
      bot.sendMessage(chatId, `‚ùå *UserID n√£o encontrado*\n\nO userId \`${targetUserId}\` n√£o possui dados no sistema.\n\nUse /debug para ver userIds dispon√≠veis.`, { parse_mode: 'Markdown' });
    }
    
  } catch (error) {
    console.error('‚ùå Erro no login:', error);
    bot.sendMessage(chatId, '‚ùå Erro durante conex√£o. Tente novamente.');
  }
}

// Comando /login antigo (compatibilidade)
bot.onText(/\/login (.+) (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const email = match[1].trim();
  const password = match[2].trim();
  
  if (!db) {
    bot.sendMessage(chatId, '‚ùå Sistema temporariamente indispon√≠vel. Tente novamente em alguns minutos.');
    return;
  }
  
  try {
    bot.sendMessage(chatId, `üîê Autenticando ${email}...`);
    
    // Por enquanto, vamos simular autentica√ß√£o e buscar userId por email
    // Em produ√ß√£o, voc√™ integraria com Firebase Auth
    const userIds = await getAllFirebaseUserIds();
    
    if (userIds.length === 0) {
      bot.sendMessage(chatId, `‚ùå *Nenhuma conta encontrada*\n\nO sistema ainda n√£o possui contas cadastradas.\n\nüåê *Cadastre-se em:*\nhttps://caderninhodigital.netlify.app`);
      return;
    }
    
    // Simular login bem-sucedido com o primeiro userId encontrado
    // Em produ√ß√£o, voc√™ validaria email/senha no Firebase Auth
    const targetUserId = userIds[0]; // Por enquanto, usar o primeiro usu√°rio
    
    const success = await authenticateUser(msg.from.id, targetUserId);
    
    if (success) {
      // Salvar informa√ß√µes do usu√°rio
      const userData = userMapping.get(msg.from.id);
      userMapping.set(msg.from.id, {
        ...userData,
        email: email,
        loginMethod: 'email_password'
      });
      
      bot.sendMessage(chatId, `‚úÖ *Login realizado com sucesso!*\n\nüë§ *Conta:* ${email}\nüÜî *ID:* \`${targetUserId}\`\nüïê *Conectado em:* ${new Date().toLocaleString('pt-BR')}\n\nüéâ *Agora voc√™ pode consultar seus dados empresariais!*\n\nüí¨ *Experimente:*\n‚Ä¢ "Quanto vendi hoje?"\n‚Ä¢ "Como est√° meu estoque?"\n‚Ä¢ "Quem s√£o meus clientes?"`, { parse_mode: 'Markdown' });
    } else {
      bot.sendMessage(chatId, `‚ùå *Falha na autentica√ß√£o*\n\nüìß Email ou senha incorretos.\n\nüí° *Dicas:*\n‚Ä¢ Verifique se digitou corretamente\n‚Ä¢ Use o mesmo email do cadastro\n‚Ä¢ Caso esqueceu a senha, acesse o sistema web\n\nüåê *Recuperar senha:*\nhttps://caderninhodigital.netlify.app`);
    }
    
  } catch (error) {
    console.error('‚ùå Erro no login:', error);
    bot.sendMessage(chatId, '‚ùå Erro durante autentica√ß√£o. Tente novamente em alguns minutos.');
  }
});

// Comando /logout - desconectar da conta
bot.onText(/\/logout/, (msg) => {
  const chatId = msg.chat.id;
  const userData = userMapping.get(msg.from.id);
  
  if (userData?.isAuthenticated) {
    // Resetar para usu√°rio n√£o autenticado
    userMapping.set(msg.from.id, {
      firebaseUserId: `telegram_${msg.from.id}`,
      firstName: msg.from.first_name,
      isAuthenticated: false,
      registeredAt: new Date()
    });
    
    bot.sendMessage(chatId, `‚úÖ *Logout realizado com sucesso!*\n\nüëã Voc√™ foi desconectado da sua conta.\n\nüîê *Para conectar novamente:*\n\`/login seu@email.com suasenha\`\n\nüåê *Sistema:* https://caderninhodigital.netlify.app`);
  } else {
    bot.sendMessage(chatId, `‚ÑπÔ∏è *Voc√™ n√£o est√° conectado*\n\nüîê *Para fazer login:*\n\`/login seu@email.com suasenha\`\n\nüåê *Cadastre-se:* https://caderninhodigital.netlify.app`);
  }
});

// Manipulador gen√©rico para mensagens de texto
bot.on('message', async (msg) => {
  const chatId = msg.chat.id;
  const userText = msg.text;

  // Ignora comandos espec√≠ficos
  if (userText.startsWith('/')) {
    return;
  }

  const userId = getUserId(msg.from.id, msg.from.first_name);

  try {
    console.log(`üí¨ Mensagem de ${msg.from.first_name}: ${userText}`);
    
    // Enviar para Groq para an√°lise
    const groqResponse = await groq.chat.completions.create({
      messages: [{
        role: "system",
        content: `Voc√™ √© um assistente IA do "Caderninho Digital", sistema de gest√£o comercial.

PERSONALIDADE:
- Seja amig√°vel, profissional e proativo
- Use emojis apropriados
- Responda de forma clara e objetiva

FUN√á√ïES DISPON√çVEIS:
- getSalesSummary(): vendas, faturamento, pagamentos pendentes
- getClientsSummary(): clientes, novos cadastros, top compradores  
- getProductsSummary(): estoque, produtos em falta, valor total

INSTRU√á√ïES:
- Analise a pergunta do usu√°rio
- Se for sobre vendas/faturamento, indique "USAR_VENDAS"
- Se for sobre clientes, indique "USAR_CLIENTES"  
- Se for sobre estoque/produtos, indique "USAR_PRODUTOS"
- Se for pergunta geral, responda normalmente
- Sempre seja √∫til e sugira pr√≥ximos passos

Exemplos:
- "Quanto vendi hoje?" ‚Üí "USAR_VENDAS - Vou buscar seu faturamento de hoje!"
- "Quantos clientes tenho?" ‚Üí "USAR_CLIENTES - Verificando seus clientes cadastrados!"
- "Produtos acabando?" ‚Üí "USAR_PRODUTOS - Analisando seu estoque!"
- "Oi" ‚Üí "Ol√°! Como posso ajudar com seu neg√≥cio hoje?"

Responda de forma conversacional e indique a a√ß√£o quando necess√°rio.`
      }, {
        role: "user",
        content: userText
      }],
      model: "llama-3.1-8b-instant",
      temperature: 0.7,
      max_tokens: 200
    });

    const aiResponse = groqResponse.choices[0]?.message?.content || "Desculpe, n√£o entendi. Pode reformular?";
    
    console.log(`ü§ñ Resposta da IA: ${aiResponse}`);

    // Processar resposta e executar a√ß√µes
    if (aiResponse.includes('USAR_VENDAS')) {
      bot.sendMessage(chatId, "üìä Buscando dados de vendas...");
      
      const summary = await getSalesSummary(userId);
      
      let response = `üìä *Resumo de Vendas*\n\n`;
      
      if (summary.isSimulated) {
        response += `‚ö†Ô∏è *Dados n√£o dispon√≠veis*\n\nPara ver dados reais:\n‚Ä¢ Acesse: https://caderninhodigital.netlify.app\n‚Ä¢ Registre suas vendas\n‚Ä¢ Volte aqui para consultar!`;
      } else if (summary.countToday === 0) {
        response += `üí∞ *Hoje:* R$ 0,00 (0 vendas)\n\nüéØ *Dica:* Que tal registrar sua primeira venda do dia?`;
      } else {
        response += `üí∞ *Hoje:* R$ ${summary.totalToday.toFixed(2)}\n`;
        response += `üõí *Vendas:* ${summary.countToday}\n`;
        response += `üìà *Ticket M√©dio:* R$ ${summary.averageTicket.toFixed(2)}\n`;
        
        if (summary.pendingPayments.length > 0) {
          response += `\nüî¥ *Pagamentos Pendentes:*\n`;
          summary.pendingPayments.slice(0, 3).forEach(p => {
            response += `‚Ä¢ ${p.clientName}: R$ ${p.remainingAmount.toFixed(2)}\n`;
          });
        }
      }
      
      bot.sendMessage(chatId, response, { parse_mode: 'Markdown' });
      
    } else if (aiResponse.includes('USAR_CLIENTES')) {
      bot.sendMessage(chatId, "üë• Buscando dados de clientes...");
      
      const summary = await getClientsSummary(userId);
      
      let response = `üë• *Gest√£o de Clientes*\n\n`;
      
      if (summary.isSimulated || summary.total === 0) {
        response += `‚ö†Ô∏è *Nenhum cliente cadastrado*\n\nüéØ *Benef√≠cios:*\n‚Ä¢ Vendas fiado organizadas\n‚Ä¢ Hist√≥rico de compras\n‚Ä¢ Controle de pagamentos\n\nüí° Cadastre em: https://caderninhodigital.netlify.app`;
      } else {
        response += `üìä *Total:* ${summary.total} clientes\n`;
        response += `üÜï *Novos este m√™s:* ${summary.newThisMonth}\n`;
        
        if (summary.topClients.length > 0) {
          response += `\nüèÜ *Top Clientes:*\n`;
          summary.topClients.slice(0, 3).forEach(c => {
            response += `‚Ä¢ ${c.name}: R$ ${c.totalPurchases.toFixed(2)}\n`;
          });
        }
      }
      
      bot.sendMessage(chatId, response, { parse_mode: 'Markdown' });
      
    } else if (aiResponse.includes('USAR_PRODUTOS')) {
      bot.sendMessage(chatId, "üì¶ Verificando estoque...");
      
      const summary = await getProductsSummary(userId);
      
      let response = `üì¶ *Controle de Estoque*\n\n`;
      
      if (summary.isSimulated || summary.total === 0) {
        response += `‚ö†Ô∏è *Nenhum produto cadastrado*\n\nüéØ *Benef√≠cios:*\n‚Ä¢ Controle de estoque\n‚Ä¢ Alertas de reposi√ß√£o\n‚Ä¢ Gest√£o de custos\n\nüí° Cadastre em: https://caderninhodigital.netlify.app`;
      } else {
        response += `üìä *Total:* ${summary.total} produtos\n`;
        response += `üí∞ *Valor do estoque:* R$ ${summary.totalValue.toFixed(2)}\n`;
        response += `‚ö†Ô∏è *Estoque baixo:* ${summary.lowStock} produtos\n`;
        
        if (summary.productsLowStock.length > 0) {
          response += `\nüî¥ *Produtos para repor:*\n`;
          summary.productsLowStock.slice(0, 3).forEach(p => {
            response += `‚Ä¢ ${p.name}: ${p.quantity} unid. (m√≠n: ${p.minQuantity})\n`;
          });
        }
      }
      
      bot.sendMessage(chatId, response, { parse_mode: 'Markdown' });
      
    } else {
      // Resposta geral da IA
      bot.sendMessage(chatId, aiResponse);
    }

  } catch (error) {
    console.error('‚ùå Erro ao processar mensagem:', error);
    bot.sendMessage(chatId, '‚ùå Ops! Houve um erro. Tente novamente ou use /ajuda para ver os comandos dispon√≠veis.');
  }
});

// Tratamento de erros do bot
bot.on('polling_error', (error) => {
  console.error('‚ùå Erro de polling:', error.code);
});

// Servidor Express para health check
const app = express();

app.get('/', (req, res) => {
  res.json({
    status: 'online',
    service: 'Caderninho Digital Chatbot IA',
    timestamp: new Date().toISOString(),
    firebase: !!db,
    groq: !!GROQ_API_KEY
  });
});

app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
});

console.log('‚úÖ Caderninho Digital Chatbot IA inicializado!');
console.log('üì± Bot pronto para receber mensagens no Telegram');
console.log('üîó Sistema: https://caderninhodigital.netlify.app');